# 第一周学习报告

## 主要侧重：数据结构

### 1）前置知识的复习

函数：1.对内隐藏细节，对外暴露接口

​            2.四种类型：无参数，无返回值；无参数，有返回值；有参数，无返回值；有参数，有返回值；**根据需求选择**！

字符串：直接赋值必须用函数strcpy();

指针：用来存放内存地址的**变量**![](C:\Users\猴猪\Desktop\指针.jpg)

内存解析：

  1.硬盘：存数据，内存：跑数据（相对于电脑）

  2.内存条、显卡、各种适配卡都有其各自的存储地址空间。操作系统将这些设备的存储地址空间抽象成一个巨大的一维数组空间。

  3.对于内存的每一个字节会分配一个32位或64位的编号，这个编号成为内存地址

  4.取地址：%p   (%zu——占字节数)

结构体

### 2）顺序表和链表  线性表：n个数据元素的有限序列

若n=0，为空表。

##### ![](C:\Users\猴猪\Pictures\Screenshots\屏幕截图 2025-10-30 145501.jpg.png)

##### 1.顺序表：

```c
#include <stdio.h>
#define MAXSIZE 100
typedef int Elemtype;//方便修改数据
int e;
//动态内存分配初始化
typedef struct{
    ElemType *data;//通用类型，下需要强制转换 
    int length;
}SeqList;
SqeList*init()//强制转换
{
    SeqList *L=(SeqList*)malloc(sizeof(SqeList));
    L->data=(ElemType*)malloc(sizeof(ElemType)*MAXSIZE);
    L->length=0;
    return L;
}
//在尾部添加元素
int appendElem(SeqList*L, Elemtype e)
{
    if (L->length >= MAXSIZE)
    {
        printf("顺序表已满\n");
        return 0;
    }
    L->data[L->length] = e;
    L->length++;
    return 1;
}
//遍历
void search(SeqList* L)
{
    for (int i = 0; i < L->length; i++) {
        printf("%d\n", L->data[i]);
    }
}
//插入元素
int add(SeqList* L, int pos, Elemtype e)
{
    if (pos <= L->length) {
        for (int i = L->length - 1; i >= pos - 1; i--) {
            L->data[i + 1] = L->data[i];
        }
        L->data[pos - 1] = e;
        L->length++;
    }
    return 1;
} 
//删除元素
int delet(SeqList* L, int pos, Elemtype* e)//用指针：不知道删除的元素的值为多少，只知道地址
{
    *e = L->data[pos - 1];
    if (pos < L->length) {
        for (int i = pos; i < L->length; i++) {
            L->data[i - 1] = L->data[i];
        }
    }
    L->length--;
    return 1;
}
//查找元素第一次出现的位置
int find(SeqList*L,ElemType e)
{
    for(int i=0;i<L->length;i++){
        if(L->data[i]==e){
            return i+1;
        }
    }
    return 0;
}
int main()
{
    SeqList *list=init();//直接接收返回值
    appendElem(&list, 88);
    appendElem(&list, 99);
    appendElem(&list, 66);
    add(&list, 2, 18);
    ElemType deldata;
    delet(&list,2,&deldata);
    printf("被删除的数据为：%d\n",deldata);
    search(&list);
    return 0;
}
```

##### 2.链表：

```c
typedef int Element;
typedef struct note
{
    Element data;
    struct node *next;
}Node;
//初始化
Node*init()
{
    Node*head=(Node*)malloc(sizeof(Node));
    head->data=0;
    head->next=NULL;
    return head;
}
//头插法
int addhead(Node*L,Element e)
{
    Node*p=(Node*)malloc(sizeof(Node));
    p->data=e;
    p->next=L->next;//必须先把新的赋值，再让旧的next指向新的地址
    L->next=p;
    return 1;
}
//遍历
void search(Node*L)
{
    Node*p=L->next;
    while(p!=NULL){
        printf("%d\n",p->data);
        p=p->next;
    }
    printf("\n");
}
//尾插法：先找到尾节点
Node*end(Node*L)
{
    Node*p=L;
    while(p->next!=NULL)
    {
        p=p->next;
    }
    return p;
}
Node*addend(Node*tail,Element e)
{
    Node*p=(Node*)malloc(sizeof(Node));
    p->data=e;
    tail->next=p;
    p->next=NULL;
    return p;
}
//在指定位置插入数据
int addnew(Node*L,int pos,Element e)
{
    Node*p=L;
    int i=0;
    //用来找到插入节点的前驱节点
    while(i<pos-1){
        p=p->next;
        i++;
        if(p==NULL){
            return 0;
        }
    }
    //要插入的新节点
    Node*q=(Node*)malloc(sizeof(Node));
    q->data=e;
    q->next=p->next;
    p->next=q;
    return 1;
}
//删除节点
int delet(Node*L,int pos)
{
    Node*p=L;
    int i=0;
    while(i<pos-1){
        p=p->next;
        i++;
        if(p==NULL){
            return 0;
        }
    }
    if(p->next==NULL)
        printf("删除的位置错误\n");
    Node*q=p->next;
    p->next=q->next;
    free(q);
    return 1;
}
//换取列表长度
int listlength(Node*L)
{
    Node*p=L;
    int len=0;
    while(p!=NULL)
    {
        p=p->next;
        len++;
    }
    return len;
}
//释放链表
void free(Node*L)
{
    Node*p=L->next;
    Node*q;
    while(p!=NULL)
    {
        q=p->next;
        free(p);
        p=q;
    }
    L->next=NULL;
}
int main()
{
    Node*list=init();
    addhead(list,10);
    addhead(list,20);
    Node*tail=end(list);
    tail=addend(tail,60);
    tail=addend(tail,40);
    addnew(list,2,66);
    delet(list,2);
    searsh(list);
    free(list);
    listlength(list);
    return 0;
}
```

![](C:\Users\猴猪\Desktop\例题.jpg)

运用快慢指针（？）

![](C:\Users\猴猪\Desktop\快慢指针.jpg)

**请问以下思路是否可行呢？**

**遍历链表，获得链表长度-->运用两个指针，找到k节点的前驱链表(总长度-(k+1))-->输出data**



### 3）栈与队列

#### 栈：限定仅在表尾进行插入或删除的线性表  先进后出/后进先出  LIFO

**栈顺序结构实现**

```c

#define MAXSIZE 100
typedef int Element;
typedef struct{
    Element data[MAXSIZE];
    int top;
}Stack;
//初始化
void init(Stack*s)
{
    s->top=-1;
}
//判断是否为空
int is(Stack*s)
{
    if(s->top==-1)
    {
        printf("空\n");
        return 1;
    }
    else
        return 0;
}
//进栈/压栈
int push(Stack*s,Element e)
{
    if(s->top>=MAXSIZE-1)
    {
        printf("满了\n");
        return 0;
    }
    s->top++;
    s->data[s->top]=e;
    return 1;
}
//出栈
Element pop(Stack*s,Element*e)
{
    if(s->top==-1)
    {
        printf("empty\n");
        return 0;
    }
    *e=s->data[s->top];
    s->top--;
    return 1;
}
//获取栈顶元素
int get(Stack*s,Element *e)
{
    if(s->top==-1)
    {
        printf("空的\n");
        return 0;
    }
    *e=s->data[s->top];
    return 1;
}
int main()
{
    Stack s;
    init(&s);
    push(&s,10);
    push(&s,20);
    push(&s,30);
    Element e;
    pop(&s,&e); 
    printf("%d\n",e);
    get(&s,&e);
    printf("%d\n",e);
    return 0;
}
```

**栈的链式结构实现**

```c
typedef int Element;
typedef struck stack
{
    Element data;
    struct stack *next;
}Stack;
//进栈
int push(Stack*s,Element e)
{
    Stack*p=(Stack*)malloc(sizeof(Stack));
    p->data=e;
    p->next=s->next;
    s->next=p;
    return 1;
}
//出栈
int pop(Stack*s,Element*e)
{
    if(s->next==NULL)
    {
        printf("空\n");
        return 0;
    }
    *e=s->next->data;
    Stack*q=s->next;
    s->next=q->next;
    free(q);
    return 1;
}
//获取栈顶元素
int get(Stack*s,Element e){
    if(s->next==NULL){
        printf("空\n");
        return 0;
    }
    *e=s->next->data;
    return 1;
}
```

**队列：先进先出 FIFO 只允许一端插入，另一端删除**

我有点燃尽了，这个队列等到下周或者以后有空的时候再学吧。

然后还有就是还要进行数据结构的习题练习，这个还没有来得及做
