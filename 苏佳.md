# Markdown语法

## 1.标题

语法：# (一级标题)  ## (二级标题)  ### (三级标题) ......

## 2.分割线

语法:  ---或者***+回车

## 3.文字显示

粗体:  用一对双星号包裹

删除线:  用一对双飘号包裹

下划线:  用一对u标签包裹

斜体:  用一对单星号包裹

高亮:  用一对双等号包裹

快捷键:

* 加粗:  Ctrl+B
* 删除线:  Shift+Alt+5
* 下划线:  Ctrl+U
* 斜体:  Ctrl+I

## 4.表格

>代码:
>
>```text
>|  1   |  2   |  3   |
>| :--- | :--: | ---: |
>|  4   |  5   |  6   |
>|  7   |  8   |  9   |
>|  10  |  11  |  12  |
>```

>效果:
>
>| 1    |  2   |    3 |
>| ---- | :--: | ---: |
>| 4    |  5   |    6 |
>| 7    |  8   |    9 |
>| 10   |  11  |   12 |

>快捷键:  Ctrl+T

## 5.代码

一行代码:用一对`号包裹

快捷键:  Ctrl+Shift+`

代码块：```加编程语言

快捷键:  Ctrl+Shift+K

## 6.链接

```
[内容](网址)
```

快捷键:  Ctrl+K

***



# 数据结构

## 1.栈

### 概念

一种**先进后出**的线性数据结构（LIFO）

### 操作

push(x):入栈

pop():出栈，从栈顶移除一个元素

top():返回栈顶元素

IstEmpty():判断栈是否为空

具体实现

```c
//数组
#define MAX_SIZE 100
typedef struct {
    int data[MAX_SIZE];
    int top;
} Stack;
void initStack(Stack *s) {
    s->top = -1;
}

bool push(Stack *s, int value) {
    if (s->top >= MAX_SIZE - 1) return false;
    s->data[++(s->top)] = value;
    return true;
}

bool pop(Stack *s, int *value) {
    if (s->top < 0) return false;
    *value = s->data[(s->top)--];
    return true;
}
//链表
typedef struct StackNode {
    int data;
    struct StackNode *next;
} StackNode;
typedef struct {
    StackNode *top;
} LinkedStack;
void push(LinkedStack *s, int value) {
    StackNode *newNode = (StackNode*)malloc(sizeof(StackNode));
    newNode->data = value;
    newNode->next = s->top;
    s->top = newNode;
}
bool pop(LinkedStack *s, int *value) {
    if (s->top == NULL) return false;
    StackNode *temp = s->top;
    *value = temp->data;
    s->top = s->top->next;
    free(temp);
    return true;
}
```

应用：

(1)反转字符串

(2)编译器撤回操作

(3)检验源代码是否匹配

(4)前缀后缀表达式的转换和求值

## 2.队列

### 概念

一种**先进先出**的线性数据结构（FIFO）

### 操作

enqueue(element)：入队

dequeue()：出队

front()：获取队首元素

isEmpty()：判断队列是否为空

代码实现：

```c
//循环数组
#define QUEUE_SIZE 100
typedef struct {
    int data[QUEUE_SIZE];
    int front;
    int rear;
    int size;
}queque;
void initQueue(queue *q) {
    q->front = 0;
    q->rear = 0;
    q->size = 0;
}
bool enqueue(queue *q, int value) {
    if (q->size == QUEUE_SIZE) return false;
    q->data[q->rear] = value;
    q->rear = (q->rear + 1) % QUEUE_SIZE;
    q->size++;
    return true;
}
bool dequeue(queue *q, int *value) {
    if (q->size == 0) return false;
    *value = q->data[q->front];
    q->front = (q->front + 1) % QUEUE_SIZE;
    q->size--;
    return true;
}
//链表
typedef struct QueueNode {
    int data;
    struct QueueNode *next;
} QueueNode;
typedef struct {
    QueueNode *front;
    QueueNode *rear;
} LinkedQueue;
void enqueue(LinkedQueue *q, int value) {
    QueueNode *newNode = (QueueNode*)malloc(sizeof(QueueNode));
    newNode->data = value;
    newNode->next = NULL;
    if (q->rear == NULL) {
        q->front = q->rear = newNode;
    } else {
        q->rear->next = newNode;
        q->rear = newNode;
    }
}
bool dequeue(LinkedQueue *q, int *value) {
    if (q->front == NULL) return false;
    QueueNode *temp = q->front;
    *value = temp->data;
    q->front = q->front->next;
    if (q->front == NULL) {
        q->rear = NULL;
    }
    free(temp);
    return true;
}
```









